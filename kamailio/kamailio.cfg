#!KAMAILIO
#
# Kamailio SBC/Proxy Configuration
# Topology: Telecom(Private) <--> Kamailio <--> Public Gateways <--> LiveKit
#
# Author: Unpod.ai Infrastructure
# Version: 1.0
#

####### Global Parameters #########

#!define WITH_DEBUG
#!define WITH_NAT
#!define WITH_ANTIFLOOD
#!define WITH_RTPENGINE

#!substdef "!PRIVATE_IP!10.0.0.100!g"
#!substdef "!PUBLIC_IP!203.0.113.50!g"
#!substdef "!PRIVATE_PORT!5060!g"
#!substdef "!PUBLIC_PORT!5080!g"
#!substdef "!RTPENGINE_SOCK!udp:127.0.0.1:2223!g"

####### Logging #########
debug=2
log_stderror=no
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

####### Core Parameters #########
fork=yes
children=8
auto_aliases=no
listen=udp:PRIVATE_IP:PRIVATE_PORT
listen=udp:PUBLIC_IP:PUBLIC_PORT
port=5060
mhomed=1
tcp_connection_lifetime=3605
tcp_max_connections=2048

####### Custom Parameters #########

# Telecom carriers (private side) - Add your carrier IPs
#!substdef "!TELECOM_CARRIER_1!10.0.1.10!g"
#!substdef "!TELECOM_CARRIER_2!10.0.1.20!g"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "jsonrpcs.so"

# Database
loadmodule "db_mysql.so"

# NAT traversal
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

# Authentication & Security
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "permissions.so"
loadmodule "htable.so"
loadmodule "pike.so"

# Dispatcher for load balancing to public gateways
loadmodule "dispatcher.so"

# Dialog tracking
loadmodule "dialog.so"

# Accounting
loadmodule "acc.so"

# HTTP for API callbacks (optional - for dynamic routing)
loadmodule "http_client.so"

####### Module Parameters ########

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "fifo_name", "/run/kamailio/kamailio_rpc.fifo")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 1)
modparam("tm", "auto_inv_100_reason", "Trying")

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@unpod.ai")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "RTPENGINE_SOCK")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_retr", 2)

# ----- dispatcher params (load balancing to public gateways) -----
modparam("dispatcher", "db_url", "mysql://kamailio:kamailiorw@localhost/kamailio")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(ds_dst)")
modparam("dispatcher", "grp_avp", "$avp(ds_grp)")
modparam("dispatcher", "cnt_avp", "$avp(ds_cnt)")
modparam("dispatcher", "sock_avp", "$avp(ds_sock)")
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_latency_stats", 1)

# ----- dialog params -----
modparam("dialog", "db_mode", 1)
modparam("dialog", "db_url", "mysql://kamailio:kamailiorw@localhost/kamailio")
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "track_cseq_updates", 1)

# ----- htable params (for rate limiting & tenant mapping) -----
# Tenant mapping: tenant_id -> gateway_group
modparam("htable", "htable", "tenants=>size=8;autoexpire=0;")
# Rate limiting per source IP
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "cps=>size=8;autoexpire=1;initval=0;")

# ----- pike params (DoS protection) -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 4)

# ----- permissions params (ACL) -----
modparam("permissions", "db_url", "mysql://kamailio:kamailiorw@localhost/kamailio")
modparam("permissions", "address_table", "address")

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", 1)
modparam("acc", "log_missed_flag", 2)
modparam("acc", "log_extra", "src_user=$fU;src_domain=$fd;src_ip=$si;dst_user=$tU;dst_domain=$td")

####### Routing Logic ########

# Main request routing
request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within dialogs
    route(WITHINDLG);

    # Record routing for all except REGISTER
    if (!is_method("REGISTER")) {
        record_route();
    }

    # Account setup
    if (is_method("INVITE")) {
        setflag(1);  # accounting flag
        setflag(4);  # dialog flag
    }

    # Dispatch based on source
    if (route(FROM_TELECOM)) {
        # Inbound from telecom (private) -> route to public gateway
        xlog("L_INFO", "INBOUND: From telecom $si to $rU\n");
        route(TO_PUBLIC_GATEWAY);
    } else if (route(FROM_PUBLIC_GATEWAY)) {
        # Inbound from public gateway -> route to telecom
        xlog("L_INFO", "OUTBOUND: From public gateway $si to $rU\n");
        route(TO_TELECOM);
    } else {
        # Unknown source - reject
        xlog("L_WARN", "BLOCKED: Unknown source $si\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }
}

# Per-request initial checks
route[REQINIT] {
    # Flood detection
    if (src_ip != myself) {
        if ($sht(ipban=>$si) != $null) {
            xdbg("Request from banned IP - $si\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT", "PIKE: Blocking $si\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }

    # Sanity checks
    if (!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP from $si:$sp\n");
        exit;
    }

    # Max forwards check
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # OPTIONS keepalive reply
    if (is_method("OPTIONS") && uri == myself) {
        sl_send_reply("200", "OK");
        exit;
    }
}

# NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);  # NAT flag
    }
}

# Handle requests within established dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(1);  # accounting
            setflag(2);  # missed call
        } else if (is_method("ACK")) {
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }

    sl_send_reply("404", "Not Found");
    exit;
}

# Check if request is from telecom (private side)
route[FROM_TELECOM] {
    # Check if source is from private network
    if ($si =~ "^10\." || $si =~ "^172\.(1[6-9]|2[0-9]|3[0-1])\." || $si =~ "^192\.168\.") {
        # Additional ACL check from database
        if (allow_source_address("1")) {
            return 1;
        }
    }
    return -1;
}

# Check if request is from public gateway
route[FROM_PUBLIC_GATEWAY] {
    # Check dispatcher list for known gateways
    if (ds_is_from_list("1")) {
        return 1;
    }
    if (ds_is_from_list("2")) {
        return 1;
    }
    # Also check permissions table
    if (allow_source_address("2")) {
        return 1;
    }
    return -1;
}

# Route to public gateway (LiveKit side)
route[TO_PUBLIC_GATEWAY] {
    # Extract tenant from various sources
    # Option 1: From X-Tenant-ID header
    if ($hdr(X-Tenant-ID) != $null) {
        $var(tenant_id) = $hdr(X-Tenant-ID);
    }
    # Option 2: From username prefix (e.g., tenant1_1234567890)
    else if ($rU =~ "^([a-zA-Z0-9]+)_") {
        $var(tenant_id) = $(rU{s.select,0,_});
        # Strip tenant prefix from destination
        $rU = $(rU{s.substr,$(var(tenant_id){s.len}),0});
        $rU = $(rU{s.strip,1});  # Remove underscore
    }
    # Option 3: Based on source IP mapping
    else {
        $var(tenant_id) = $sht(tenants=>$si);
        if ($var(tenant_id) == $null) {
            $var(tenant_id) = "default";
        }
    }

    xlog("L_INFO", "Routing for tenant: $var(tenant_id)\n");

    # Map tenant to dispatcher group
    # Group 1: Default gateways
    # Group 2: Premium gateways
    # Group 3: Backup gateways
    $var(ds_group) = 1;
    if ($var(tenant_id) == "premium") {
        $var(ds_group) = 2;
    }

    # Select gateway with load balancing (round-robin with failover)
    if (!ds_select_dst("$var(ds_group)", "4")) {
        # Try backup group
        if (!ds_select_dst("3", "4")) {
            xlog("L_ERR", "No available gateways for tenant $var(tenant_id)\n");
            sl_send_reply("503", "Service Unavailable");
            exit;
        }
    }

    # Store original source for return path
    $dlg_var(src_ip) = $si;
    $dlg_var(src_port) = $sp;
    $dlg_var(tenant_id) = $var(tenant_id);

    # NAT handling - switch to public IP for outbound
    route(NATMANAGE);

    # Add custom headers for LiveKit/gateway
    append_hf("X-Tenant-ID: $var(tenant_id)\r\n");
    append_hf("X-Original-IP: $si\r\n");
    append_hf("X-Forwarded-For: $si\r\n");

    # Set failure route for failover
    t_on_failure("GW_FAILOVER");

    route(RELAY);
}

# Route to telecom (private side)
route[TO_TELECOM] {
    # Determine destination telecom based on:
    # Option 1: X-Destination-Carrier header
    if ($hdr(X-Destination-Carrier) != $null) {
        $var(carrier) = $hdr(X-Destination-Carrier);
    }
    # Option 2: From dialog variable (return path)
    else if ($dlg_var(src_ip) != $null) {
        $ru = "sip:" + $rU + "@" + $dlg_var(src_ip) + ":" + $dlg_var(src_port);
        route(NATMANAGE);
        route(RELAY);
        exit;
    }
    # Option 3: LCR based on destination number
    else {
        # Simple routing based on number prefix
        # Indian numbers
        if ($rU =~ "^91[6-9][0-9]{9}$") {
            $var(carrier) = "carrier1";
        } else {
            $var(carrier) = "default";
        }
    }

    # Route to appropriate carrier
    switch($var(carrier)) {
        case "carrier1":
            $ru = "sip:" + $rU + "@TELECOM_CARRIER_1:5060";
            break;
        case "carrier2":
            $ru = "sip:" + $rU + "@TELECOM_CARRIER_2:5060";
            break;
        default:
            $ru = "sip:" + $rU + "@TELECOM_CARRIER_1:5060";
    }

    # Force socket for private network
    $fs = "udp:PRIVATE_IP:PRIVATE_PORT";

    route(NATMANAGE);
    route(RELAY);
}

# Relay with NAT handling
route[RELAY] {
    # Enable SIP response handling
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }

    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# NAT management
route[NATMANAGE] {
    if (is_request()) {
        if (has_body("application/sdp")) {
            # Determine direction for RTPEngine
            if (route(FROM_TELECOM)) {
                # Private to Public: internal -> external
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP internal external");
            } else {
                # Public to Private: external -> internal  
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP external internal");
            }
        }
    }

    if (is_reply()) {
        if (has_body("application/sdp")) {
            if (route(FROM_TELECOM)) {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP external internal");
            } else {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP internal external");
            }
        }
    }
}

# Branch management
branch_route[MANAGE_BRANCH] {
    xdbg("New branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Reply handling
onreply_route[MANAGE_REPLY] {
    xdbg("Incoming reply\n");
    
    if (status =~ "[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Gateway failover
failure_route[GW_FAILOVER] {
    if (t_is_canceled()) exit;

    # Mark failed gateway
    if (t_check_status("500|503")) {
        ds_mark_dst("ip");
        
        # Try next gateway in group
        if (ds_next_dst()) {
            xlog("L_INFO", "Failover to next gateway: $ru\n");
            route(NATMANAGE);
            t_on_failure("GW_FAILOVER");
            t_relay();
            exit;
        }
    }

    # If 408 timeout, also try failover
    if (t_check_status("408")) {
        ds_mark_dst("ip");
        if (ds_next_dst()) {
            xlog("L_INFO", "Timeout failover to: $ru\n");
            t_on_failure("GW_FAILOVER");
            t_relay();
            exit;
        }
    }

    # No more gateways - send error upstream
    xlog("L_ERR", "All gateways failed for $rU\n");
}

####### Event Routes ########

event_route[dispatcher:dst-down] {
    xlog("L_WARN", "Gateway down: $ru\n");
}

event_route[dispatcher:dst-up] {
    xlog("L_INFO", "Gateway up: $ru\n");
}
