#!KAMAILIO
#
# Kamailio SBC/Proxy Configuration
# Topology: Telecom(Private) <--> Kamailio <--> Public Gateways <--> LiveKit
#
# Author: Unpod.ai Infrastructure
# Version: 2.0
#
# ============================================
# CALL FLOWS:
# ============================================
# INBOUND (Telecom → Voice AI):
#   Vodafone(10.230.73.220) → Private(10.230.73.225:5060) → Public(103.146.242.234:5060) → VAPI/LiveKit
#   - All headers to VAPI/LiveKit use 103.146.242.234
#
# OUTBOUND (Voice AI → Telecom):
#   VAPI/LiveKit → Public(103.146.242.234:5060) → Private(10.230.73.225:5060) → Vodafone(10.230.73.220)
#   - All headers to Vodafone use 10.230.73.225
# ============================================

####### Global Parameters #########

#!define WITH_DEBUG
#!define WITH_NAT
#!define WITH_ANTIFLOOD
#!define WITH_RTPENGINE

#!substdef "!PRIVATE_IP!10.230.73.225!g"
#!substdef "!PUBLIC_IP!103.146.242.234!g"
#!substdef "!PRIVATE_PORT!5060!g"
#!substdef "!PUBLIC_PORT!5060!g"
#!substdef "!VODAFONE_IP!10.230.73.220!g"
#!substdef "!RTPENGINE_SOCK!udp:127.0.0.1:2223!g"

####### Logging #########
debug=2
log_stderror=no
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

####### Core Parameters #########
fork=yes
children=8
auto_aliases=no
listen=udp:PRIVATE_IP:PRIVATE_PORT
listen=udp:PUBLIC_IP:PUBLIC_PORT
listen=tcp:PUBLIC_IP:PUBLIC_PORT
port=5060
mhomed=1

# Aliases so "myself" matches our listening IPs (for OPTIONS responses)
alias=PRIVATE_IP
alias=PUBLIC_IP

tcp_connection_lifetime=3605
tcp_max_connections=2048

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "jsonrpcs.so"

# Database
loadmodule "db_mysql.so"
loadmodule "sqlops.so"

# NAT traversal
loadmodule "usrloc.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

# Security
loadmodule "permissions.so"
loadmodule "htable.so"
loadmodule "pike.so"

# Dispatcher for load balancing to public gateways
loadmodule "dispatcher.so"

# UAC for header manipulation
loadmodule "uac.so"

# Dialog tracking
loadmodule "dialog.so"

# Accounting
loadmodule "acc.so"

####### Module Parameters ########

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "fifo_name", "/run/kamailio/kamailio_rpc.fifo")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 1)
modparam("tm", "auto_inv_100_reason", "Trying")

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)

# ----- usrloc params -----
modparam("usrloc", "nat_bflag", 7)
modparam("usrloc", "db_mode", 0)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@unpod.ai")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "RTPENGINE_SOCK")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_retr", 2)

# ----- dispatcher params -----
modparam("dispatcher", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1:3306/kamailio")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_probing_mode", 1)

# ----- sqlops params -----
modparam("sqlops", "sqlcon", "ca=>mysql://kamailio:kamailiorw@127.0.0.1:3306/kamailio")

# ----- dialog params -----
modparam("dialog", "db_mode", 1)
modparam("dialog", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1:3306/kamailio")
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "track_cseq_updates", 1)

# ----- htable params -----
modparam("htable", "htable", "tenants=>size=8;autoexpire=0;")
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "cps=>size=8;autoexpire=1;initval=0;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 4)

# ----- permissions params -----
modparam("permissions", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1:3306/kamailio")
modparam("permissions", "address_table", "address")

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", 1)
modparam("acc", "log_missed_flag", 2)
modparam("acc", "log_extra", "src_user=$fU;src_domain=$fd;src_ip=$si;dst_user=$tU;dst_domain=$td")

####### Routing Logic ########

# Main request routing
request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within dialogs
    route(WITHINDLG);

    # Account setup
    if (is_method("INVITE")) {
        setflag(1);
        setflag(4);
    }

    # ============================================
    # DIRECTION DETECTION BASED ON RECEIVING INTERFACE
    # ============================================
    # $Ri = IP address of the interface that received the request

    if ($Ri == "PRIVATE_IP") {
        # Request received on PRIVATE interface (10.230.73.225)
        # This is INBOUND: Telecom → Public Gateway
        xlog("L_INFO", "INBOUND: Received on private interface from $si, dest=$rU\n");
        route(ROUTE_TO_PUBLIC);
    } else if ($Ri == "PUBLIC_IP") {
        # Request received on PUBLIC interface (103.146.242.234)
        # This is OUTBOUND: Public Gateway → Telecom
        xlog("L_INFO", "OUTBOUND: Received on public interface from $si, dest=$rU\n");
        route(ROUTE_TO_PRIVATE);
    } else {
        xlog("L_WARN", "BLOCKED: Unknown receiving interface $Ri from $si\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }
}

# ============================================
# REQINIT - Initial request checks
# ============================================
route[REQINIT] {
    # OPTIONS keepalive - respond immediately
    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # Flood detection
    if (src_ip != myself) {
        if ($sht(ipban=>$si) != $null) {
            xdbg("Request from banned IP - $si\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT", "PIKE: Blocking $si\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }

    # Sanity checks
    if (!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP from $si:$sp\n");
        exit;
    }

    # Max forwards check
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }
}

# NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        setflag(5);
    }
}

# Handle requests within established dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(1);
            setflag(2);
        } else if (is_method("ACK")) {
            route(NATMANAGE);
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }

    sl_send_reply("404", "Not Found");
    exit;
}

# ============================================
# ROUTE_TO_PUBLIC - Telecom → Public Gateway
# ============================================
# Received on PRIVATE interface, send out PUBLIC interface
# All headers visible to VAPI/LiveKit must use PUBLIC_IP
route[ROUTE_TO_PUBLIC] {
    xlog("L_INFO", "ROUTE_TO_PUBLIC: Routing $rU from telecom to public gateway\n");

    # Select gateway using dispatcher (default group 1 = VAPI)
    $var(ds_group) = 1;

    # DID-based routing lookup
    if (sql_query("ca", "SELECT gateway_group FROM did_routing WHERE did='$rU' AND enabled=1 LIMIT 1", "ra")) {
        if ($dbr(ra=>rows) > 0) {
            $var(ds_group) = $dbr(ra=>[0,0]);
            xlog("L_INFO", "DID routing: $rU -> Group $var(ds_group)\n");
        }
    }

    # Select gateway
    if (!ds_select_dst("$var(ds_group)", "4")) {
        xlog("L_WARN", "No gateway in group $var(ds_group), trying backup (3)\n");
        if (!ds_select_dst("3", "4")) {
            sl_send_reply("503", "Service Unavailable");
            exit;
        }
    }

    xlog("L_INFO", "Selected gateway: $du\n");

    # Force send from PUBLIC interface
    $fs = "udp:PUBLIC_IP:PUBLIC_PORT";

    # Set Request-URI to destination number @ gateway
    $var(gw_host) = $(du{uri.host});
    $ru = "sip:" + $rU + "@" + $var(gw_host);

    # ============================================
    # REWRITE HEADERS FOR PUBLIC NETWORK
    # VAPI/LiveKit only sees PUBLIC_IP (103.146.242.234)
    # ============================================

    # Rewrite From header: replace private/carrier IP with public IP
    subst('/^(From:.*sip:[^@]+@)[^;>]+(.*)$/\1PUBLIC_IP\2/i');

    # Rewrite To header: replace private IP with gateway host
    subst('/^(To:.*sip:[^@]+@)[^;>]+(.*)$/\1$var(gw_host)\2/i');

    # Contact: use PUBLIC_IP
    remove_hf("Contact");
    append_hf("Contact: <sip:$fU@PUBLIC_IP:PUBLIC_PORT>\r\n");

    # Record-Route with PUBLIC IP
    if (!is_method("REGISTER")) {
        record_route_preset("PUBLIC_IP:PUBLIC_PORT");
    }

    # RTPEngine: internal → external
    if (has_body("application/sdp")) {
        rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP internal external");
    }

    t_on_failure("GW_FAILOVER");
    route(RELAY);
}

# ============================================
# ROUTE_TO_PRIVATE - Public Gateway → Telecom
# ============================================
# Received on PUBLIC interface, send out PRIVATE interface
# All headers visible to Vodafone must use PRIVATE_IP
route[ROUTE_TO_PRIVATE] {
    xlog("L_INFO", "ROUTE_TO_PRIVATE: Routing $rU from public gateway to Vodafone\n");

    # Force send from PRIVATE interface
    $fs = "udp:PRIVATE_IP:PRIVATE_PORT";

    # Set destination to Vodafone
    $ru = "sip:" + $rU + "@VODAFONE_IP:5060";

    # ============================================
    # REWRITE HEADERS FOR PRIVATE NETWORK
    # Vodafone only sees PRIVATE_IP (10.230.73.225)
    # ============================================

    # Rewrite From header: replace public gateway IP with private IP
    subst('/^(From:.*sip:[^@]+@)[^;>]+(.*)$/\1PRIVATE_IP\2/i');

    # Rewrite To header: replace public IP with Vodafone IP, add + for Indian numbers
    subst('/^(To:.*sip:)([^@]+)(@)[^;>]+(.*)$/\1\2\3VODAFONE_IP\4/i');

    # Contact: use PRIVATE_IP
    remove_hf("Contact");
    append_hf("Contact: <sip:$fU@PRIVATE_IP:PRIVATE_PORT>\r\n");

    # Record-Route with PRIVATE IP
    if (!is_method("REGISTER")) {
        record_route_preset("PRIVATE_IP:PRIVATE_PORT");
    }

    # RTPEngine: external → internal
    if (has_body("application/sdp")) {
        rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP external internal");
    }

    route(RELAY);
}

# Relay
route[RELAY] {
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }

    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# NAT management for replies
route[NATMANAGE] {
    if (is_reply()) {
        if (has_body("application/sdp")) {
            # Check original request direction by received interface stored in dialog
            # For now, use a simple approach based on response source
            rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP");
        }
    }
}

# Branch management
branch_route[MANAGE_BRANCH] {
    xdbg("New branch [$T_branch_idx] to $ru\n");
}

# Reply handling
onreply_route[MANAGE_REPLY] {
    xdbg("Incoming reply from $si\n");

    if (status =~ "[12][0-9][0-9]") {
        if (has_body("application/sdp")) {
            # Handle SDP in replies
            if ($si =~ "^10\.") {
                # Reply from private network, going to public
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP internal external");
            } else {
                # Reply from public network, going to private
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP external internal");
            }
        }
    }
}

# Gateway failover
failure_route[GW_FAILOVER] {
    if (t_is_canceled()) exit;

    if (t_check_status("500|503|408")) {
        ds_mark_dst("ip");

        if (ds_next_dst()) {
            xlog("L_INFO", "Failover to next gateway: $ru\n");
            t_on_failure("GW_FAILOVER");
            t_relay();
            exit;
        }
    }

    xlog("L_ERR", "All gateways failed for $rU\n");
}

####### Event Routes ########

event_route[dispatcher:dst-down] {
    xlog("L_WARN", "Gateway down: $ru\n");
}

event_route[dispatcher:dst-up] {
    xlog("L_INFO", "Gateway up: $ru\n");
}
